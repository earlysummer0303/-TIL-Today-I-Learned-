// 상속의 한계점 및 단점

// 하나의 클래스는 한개의 클래스만 상속 할 수 있다 (오직 하나의 부모클래스, 다중상속 금지)
// 자식클래스는 본적인 상위클래스의 메모리 구조를 그대로 따라가기 때문에, 굳이 필요하지 않은 속성이나 매서드까지 상속한다.
// 상속은 클래스(래퍼런스 타입) 에서만 가능하다.

// 따라서 이러한 점들을 해소할 수 있는 새로운 패러다임인 '프로토콜'이 도입됨.


// 프로토콜

// 프로토콜은, 해당 프로토콜이 요구하는 요구사항을 충족하는 타입에 대해, 프로토콜을 채택해, 해당 요구사항의 기능을 사용 가능하다.


// 프로토콜 만들기

protocol SomeProtocol { // 매서드, 혹은 속성의 형태로 요구사항을 정의
    var num: Int {get set}
    func doThis() // 함수 내부의 구현은 프로토콜 안에서 하지 않고, 함수를 표기만 해주며, 프로토콜을 채택한 타입 내에서 직접 구현한다.
}


// 프로토콜을 '채택' 하는 타입의 구현

struct ThisStruct: SomeProtocol { // 프로토콜의 채택
    var num: Int = 0 // 프로토콜을 채택한 타입은, 내부에서 요구사항의 함수를 구현해야 한다. 프로토콜을 채택하고, 요구사항을 구현하지 않으면 에러발생
    func doThis(){
        print("안녕 안녕")
    }
}


// 다른 클래스를 상속하는 클래스에서의 프로토콜 채택

class A {
    var a: Int = 0
}

class B: A, SomeProtocol { // 다른 클래스를 상속하는 클래스가 프로토콜을 채택할땐, 상속하는 클래스 명을 먼저 적어주고, 그 다음 채택할 프로토콜(들)을 ,로 나열한다.
    var b: Int = 0
    var num: Int = 0 // 프로토콜 요구사항 충족 - 1
    func doThis(){ // 프로토콜 요구사항 충족 - 2
        print("클래스의 프로토콜 채택")
    }
}


// 프로토콜은 하나의 타입처럼 사용 가능하다.

let someProtocolList : [SomeProtocol] = [ThisStruct(), B()]
